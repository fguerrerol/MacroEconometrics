library("tstools")
library("xts")
library("zoo")
library("vars")
library("tidyverse")
##### Ejercicio 1 #####
# Como primer paso, reporte el traspaso incondicional (hasta 12 meses adelante), computados con un modelo VAR
# como el visto en las clases pr ́acticas.2 Esto es, un modelo que incluya el  ́ındice de precios externos, el tipo de
# cambio nominal oficial y el IPC nivel general3 (todas en diferencias logar ́ıtmicas) identificando el shock cambiario
# como el correspondiente a la ecuación del tipo de cambio, utilizando restricciones de corto plazo recursivas. Elija
# el numero de rezagos del VAR usando criterios de informaci ́on, e imponga el supuesto de exogeneidad fuerte para
# el  ́ındice de precios internacionales. Presente tambi ́en gr ́aficos an ́alogos con un modelo que excluya el indice de
# precios externos, y compare los resultados obtenidos.
### Inicio ###
### Para iniciar construyo el Modelo VAR ###
### Este modelo incluye  las variables ####
### Indice de precios externos
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("PS3_LP_Tools.R")
source("PS2_SVAR_Tools.R")
source("PS2_SVAR_Plots.R")
source("PS3_SVAR_Tools.R")
source("PS3_SIRF_Transform.R")
source("PS3_SVAR_LR.R")
source("PS3_LP_Tools.R")
m2 <- read_excel("M2.xls",sheet=2)
m2 = ts(m2[-(1),2], start = c(1986, 1) , frequency = 12)
tdc_nom <- read_excel("tdc_nominal.xls")
tdc_nom = ts(tdc_nom[-(1),2], start = c(2002, 1) , frequency = 12)
ipc <- read.csv("ipc_1943_act.csv")
ipc = ts(ipc[3],start = c(1943,1),frequency = 12)
r_bruta <- read_excel("RemuneracionBruta_OEDE.xlsx")
r_bruta = ts(r_bruta[-(1),3], start = c(1995, 1) , frequency = 12)
dolar_cot <- read.csv("dolar-cot.csv")
dolar_cot = ts(dolar_cot[2], start = c(1995, 1) , frequency = 12)
emae <- read_xls("emae.xls")
emae = ts(emae[-1,3], start = c(2004, 1) , frequency = 12)
p_int <- read_excel("precios_int.xls")
p_int <- ts(p_int[2], start = c(1997, 1) , frequency = 12)
ipc <- window(ipc,start = c(2002,1))
p_int <- window(p_int,start = c(2002,1))
tdc_nom <-window(tdc_nom, start= c(2002,1))
ts.plot(ipc, type="l", lwd=2, xlab="",ylab="%",bty="n", main = "Índice de precios al consumidor")
ts.plot(p_int, type="l", lwd=2, xlab="",ylab="%",bty="n", main = "Nivel de precios Internacionales")
ts.plot(tdc_nom, type="l", lwd=2, xlab="",ylab="%",bty="n", main = "Tasa de cambio nominal")
l_ipc <-log(ipc)
l_p_int <-log(p_int)
l_tdc_n <-log(tdc_nom)
ts.plot(l_ipc, type="l", lwd=2, xlab="",ylab="%",bty="n", main = " Logaritmo Índice de precios al consumidor")
ts.plot(l_p_int, type="l", lwd=2, xlab="",ylab="%",bty="n", main = "Logaritmo de los precios  Internacionales")
ts.plot(l_tdc_n, type="l", lwd=2, xlab="",ylab="%",bty="n", main = "Logaritmo de la tasa de cambio nominal")
d_l_ipc  <- diff(l_ipc)
d_l_p_int <- diff(l_p_int)
d_l_tdc_n <- diff(l_tdc_n)
ts.plot(d_l_ipc, type="l", lwd=2, xlab="",ylab="%",bty="n", main = " Diff Logaritmo Índice de precios al consumidor")
ts.plot(d_l_p_int, type="l", lwd=2, xlab="",ylab="%",bty="n", main = "Diff Logaritmo de los precios  Internacionales")
ts.plot(d_l_tdc_n, type="l", lwd=2, xlab="",ylab="%",bty="n", main = " Diff Logaritmo de la tasa de cambio nominal")
#### Parte 1 ####
# Generamos el modelo completo en el cual tomamos en consideración
### Subsetteeo con tal que omito el problema de los NAN, hasta lo máximo
### que se puede recortat
d_l_ipc <-window(d_l_ipc,start=c(2004,1),end=c(2019,12))
d_l_tdc_n <-window(d_l_tdc_n,start=c(2004,1),end=c(2019,12))
d_l_p_int <-window(d_l_p_int,start=c(2004,1),end=c(2019,12))
modelo_1 <- cbind(d_l_p_int,
d_l_tdc_n,
d_l_ipc)
var_1 <- VARselect(modelo_1, lag.max = 15, type = "const")
var_1
p<- var_1$selection[1]
p
### Bajo el criterio de infomración de Akaike se encuentra que el
### número óptimo de rezagos para este modelo que posee 3 variables
### es igual a  3
### Generamos el modelo y obtenemos las estadísticas sumarias
VAR1 <- VAR(modelo_1, p = p, type = "const")
summary(VAR1)
m <- VAR1$K # Number of variables in the VAR
T <- VAR1$obs # Number of effective sample observations, excluding "p" starting values
### Ploteo los residuos del VAR
e <- resid(VAR1)
e <- ts(e, end = end(modelo_1), frequency = frequency(modelo_1))
colnames(e) <- c(1,2,3)
plot(e, main = "Residuals")
#### Genero esta minifuncion para restringir el feedback hacia
#### las variables locales
matC <- function(m, p, vx) {
vy <- setdiff(1:m, vx)
Cm <- matrix(1, m, m * p + 1)
for (i in vx) {
for (l in 1:p) {
for (j in vy) {
Cm[i, m * (l - 1) + j] <- 0
}
}
}
Cm
}
### Aplico la función para restringir a la matriz####
#### con la función restrict restrinjo el VAR que hize líneas atras
constraints <- matC(m, p, 2)
VAR1 <- restrict(VAR1, method = "man", resmat = constraints)
VAR1
#### Vemos que las raíces unitarias dan menor que uno por lo tanto
#### prosigo
roots(VAR1, modulus = TRUE)
#### Genero las matrices para elaborar el VAR estructural
# A Matrix
Amat <- diag(m)
for (i in 2:m) {
for (j in 1:(i - 1)) {
Amat[i, j] <- NA
}
}
# B Matrix
Bmat <- matrix(0, m, m)
for (i in 1:m) {
Bmat[i, i] <- NA
}
### Creo y asigno el VAR estructural
SVAR <- SVAR(VAR1, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
SVAR
H.ERPT <- 12 # Horizon (ERPT)
ERPT2 <- SVAR.erpt(SVAR, H.ERPT, 3, 2)
plot.erpt2(ERPT2, H.ERPT)
ERPT3 <- SVAR.erpt(SVAR, H.ERPT, 1, 2)
#plot.erpt3(ERPT3, H.ERPT)
####  Modelo modificaado ######
### Ahora elaboro el modelo VAR pero sin un variable ###
### Para esto genero el VAR teniendo en consideracion solo ###
### Este modelo se va a llamar modelo 2 y su VAR ####
### correspondiente se va a designar VAR2####
modelo_2 <- cbind(d_l_tdc_n,
d_l_ipc)
var_2 <- VARselect(modelo_2, lag.max = 15, type = "const")
var_2
p2<- var_2$selection[2]
p2
### El valor de p2, nos dice que los rezagos adecuados son 3
### con esto se va a proceder
### Generamos el modelo y obtenemos las estadísticas sumarias
VAR2 <- VAR(modelo_2, p = p2, type = "const")
summary(VAR2)
m <- VAR2$K # Number of variables in the VAR
T <- VAR2$obs # Number of effective sample observations, excluding "p" starting values
### Ploteo los residuos del VAR
e <- resid(VAR2)
e <- ts(e, end = end(modelo_2), frequency = frequency(modelo_2))
colnames(e) <- c(1,2)
plot(e, main = "Residuals")
#### Genero esta minifuncion para restringir el feedback hacia
#### las variables locales
matC <- function(m, p, vx) {
vy <- setdiff(1:m, vx)
Cm <- matrix(1, m, m * p + 1)
for (i in vx) {
for (l in 1:p) {
for (j in vy) {
Cm[i, m * (l - 1) + j] <- 0
}
}
}
Cm
}
### Aplico la función para restringir a la matriz####
#### con la función restrict restrinjo el VAR que hize líneas atras
constraints <- matC(m, p2, 1)
VAR2 <- restrict(VAR2, method = "man", resmat = constraints)
VAR2
#### Vemos que las raíces unitarias dan menor que uno por lo tanto
#### prosigo
roots(VAR2, modulus = TRUE)
#### Genero las matrices para elaborar el VAR estructural
# A Matrix
Amat <- diag(m)
for (i in 2:m) {
for (j in 1:(i - 1)) {
Amat[i, j] <- NA
}
}
# B Matrix
Bmat <- matrix(0, m, m)
for (i in 1:m) {
Bmat[i, i] <- NA
}
R <- 500 # Number of bootstrap replications
type <- "nonparametric"
gamma <- 0.95 # Confidence level
SVAR2 <- SVAR(VAR2, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
Y.boot <- boot.replicate(VAR2, R, type)
m
ERPT <- SVAR.erpt.boot(SVAR,Amat, Bmat, H.ERPT, 2, 1, gamma, Y.boot)
plot.erpt.boot(ERPT, H.ERPT)
Bmat
Amat
ERPT <- SVAR.erpt.boot(SVAR2,Amat, Bmat, H.ERPT, 2, 1, gamma, Y.boot)
H.ERPT
source("PS2_SVAR_Tools.R")
source("PS2_SVAR_Plots.R")
ERPT <- SVAR.erpt.boot(SVAR2,Amat, Bmat, H.ERPT, 2, 1, gamma, Y.boot)
plot.erpt.boot(ERPT,H.ERPT)
plot.erpt.boot(ERPT,H.ERPT)
ERPT2 <- SVAR.erpt(SVAR, H.ERPT, 3, 2)
VAR1 <- VAR(modelo_1, p = p, type = "const")
summary(VAR1)
m <- VAR1$K # Number of variables in the VAR
T <- VAR1$obs # Number of effective sample observations, excluding "p" starting values
### Ploteo los residuos del VAR
e <- resid(VAR1)
e <- ts(e, end = end(modelo_1), frequency = frequency(modelo_1))
colnames(e) <- c(1,2,3)
plot(e, main = "Residuals")
matC <- function(m, p, vx) {
vy <- setdiff(1:m, vx)
Cm <- matrix(1, m, m * p + 1)
for (i in vx) {
for (l in 1:p) {
for (j in vy) {
Cm[i, m * (l - 1) + j] <- 0
}
}
}
Cm
}
constraints <- matC(m, p, 2)
VAR1 <- restrict(VAR1, method = "man", resmat = constraints)
VAR1
roots(VAR1, modulus = TRUE)
# A Matrix
Amat <- diag(m)
for (i in 2:m) {
for (j in 1:(i - 1)) {
Amat[i, j] <- NA
}
}
# B Matrix
Bmat <- matrix(0, m, m)
for (i in 1:m) {
Bmat[i, i] <- NA
}
### Creo y asigno el VAR estructural
SVAR <- SVAR(VAR1, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
SVAR
H.ERPT <- 12 # Horizon (ERPT)
ERPT_1 <- SVAR.erpt.boot(SVAR2,Amat, Bmat, H.ERPT, 3, 2, gamma, Y.boot)
Y.boot <- boot.replicate(VAR1, R, type)
ERPT_1 <- SVAR.erpt.boot(SVAR2,Amat, Bmat, H.ERPT, 3, 2, gamma, Y.boot)
gamma <- 0.95 # Confidence level
### Creo y asigno el VAR estructural
SVAR <- SVAR(VAR1, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
modelo_1 <- cbind(d_l_p_int,
d_l_tdc_n,
d_l_ipc)
var_1 <- VARselect(modelo_1, lag.max = 15, type = "const")
var_1
p<- var_1$selection[1]
p
VAR1 <- VAR(modelo_1, p = p, type = "const")
summary(VAR1)
m <- VAR1$K # Number of variables in the VAR
T <- VAR1$obs # Number of effective sample observations, excluding "p" starting values
e <- resid(VAR1)
e <- ts(e, end = end(modelo_1), frequency = frequency(modelo_1))
colnames(e) <- c(1,2,3)
plot(e, main = "Residuals")
constraints <- matC(m, p, 2)
VAR1 <- restrict(VAR1, method = "man", resmat = constraints)
VAR1
Amat <- diag(m)
for (i in 2:m) {
for (j in 1:(i - 1)) {
Amat[i, j] <- NA
}
}
# B Matrix
Bmat <- matrix(0, m, m)
for (i in 1:m) {
Bmat[i, i] <- NA
}
R <- 500 # Number of bootstrap replications
type <- "nonparametric"
gamma <- 0.95 # Confidence level
### Creo y asigno el VAR estructural
SVAR <- SVAR(VAR1, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
SVAR
H.ERPT <- 12 # Horizon (ERPT)
Y.boot <- boot.replicate(VAR1, R, type)
ERPT_1 <- SVAR.erpt.boot(SVAR2,Amat, Bmat, H.ERPT, 3, 2, gamma, Y.boot)
ERPT_1 <- SVAR.erpt.boot(SVAR2,Amat, Bmat, H.ERPT, 2, 1, gamma, Y.boot)
ERPT_1 <- SVAR.erpt.boot(SVAR2,Amat, Bmat, H.ERPT, 3, 1, gamma, Y.boot)
ERPT_1 <- SVAR.erpt.boot(SVAR2,Amat, Bmat, H.ERPT, 1, 3, gamma, Y.boot)
ERPT_1 <- SVAR.erpt.boot(SVAR2,Amat, Bmat, H.ERPT, m, p, gamma, Y.boot)
ERPT_1 <- SVAR.erpt.boot(SVAR,Amat, Bmat, H.ERPT, 2, 3, gamma, Y.boot)
### Creo y asigno el VAR estructural
SVAR <- SVAR(VAR1, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
SVAR
H.ERPT <- 12 # Horizon (ERPT)
Y.boot <- boot.replicate(VAR1, R, type)
ERPT_1 <- SVAR.erpt.boot(SVAR,Amat, Bmat, H.ERPT, 2, 3, gamma, Y.boot)
ERPT_1 <- SVAR.erpt.boot(SVAR,Amat, Bmat, H.ERPT, 3, 2, gamma, Y.boot)
source("PS2_Bootstrap.R")
source("PS2_Miscellaneous.R")
# SVAR Tools ####
companion <- function(Phi, m, p) {
if (p == 1) {
matrix(Phi, m, m)
} else {
rbind(matrix(Phi, m, m * p), cbind(diag(m * (p - 1)), matrix(0, m * (p - 1), m)))
}
}
var2vma <- function(Phi, P, m, p, H) {
F <- companion(Phi, m, p)
F.temp <- F
I <- array(NA, c(m, m, H + 1))
I[, , 1] <- P
for (h in 1:H) {
I[, , h + 1] <- F.temp[1:m, 1:m] %*% P
F.temp <- F.temp %*% F
}
I
}
sirf <- function(Phi, P, m, p, H, cumulative = FALSE) {
I <- var2vma(Phi, P, m, p, H)
if (isFALSE(cumulative)) {
I
} else {
aperm(apply(I, c(1, 2), cumsum), c(2, 3, 1))
}
}
fevd <- function(Phi, P, m, p, H) {
I <- var2vma(Phi, P, m, p, H)
M <- I[, , 1] ^ 2
J <- tcrossprod(I[, , 1])
W <- array(NA, c(m, m, H + 1))
W[, , 1] <- M / diag(J)
for (h in 2:(H + 1)) {
M <- M + I[, , h] ^ 2
J <- J + tcrossprod(I[, , h])
W[, , h] <- M / diag(J)
}
100 * W
}
hd <- function(Phi, P, Y, E, m, p, T) {
I <- var2vma(Phi, P, m, p, T - 1)
U <- t(solve(P, t(E)))
hist.decomp <- array(NA, c(m, m + 1, T))
for (t in 1:T) {
for (j in 1:m) {
for (i in 1:m) {
hist.decomp[i, j, t] <- c(crossprod(I[i, j, 1:t], U[t:1, j]))
}
}
}
non.stochastic <- Y - t(apply(hist.decomp[, 1:m, ], c(1, 3), sum))
for (i in 1:m) {
hist.decomp[i, m + 1, ] <- non.stochastic[, i]
}
hist.decomp
}
erpt <- function(Phi, P, m, p, H, vx, vy, cumulative = TRUE) {
if (isTRUE(cumulative)) {
I <- sirf(Phi, P, m, p, H, cumulative = TRUE)
} else {
I <- sirf(Phi, P, m, p, H)
}
100 * (I[vx, vy, ] / I[vy, vy, ])
}
# SVAR Tools (vars) ####
SVAR.sirf <- function(SVAR, H, cumulative = FALSE) {
Y <- SVAR$var$y
m <- SVAR$var$K
p <- SVAR$var$p
B <- VAR.coefficients(SVAR$var)
P <- solve(SVAR$A, SVAR$B)
SIRF <- sirf(B$Phi, P, m, p, H, cumulative = cumulative)
dimnames(SIRF)[[1]] <- toupper(colnames(Y))
dimnames(SIRF)[[2]] <- paste("S.", 1:m, sep = "")
dimnames(SIRF)[[3]] <- 0:H
SIRF
}
SVAR.fevd <- function(SVAR, H) {
Y <- SVAR$var$y
m <- SVAR$var$K
p <- SVAR$var$p
B <- VAR.coefficients(SVAR$var)
P <- solve(SVAR$A, SVAR$B)
FEVD <- fevd(B$Phi, P, m, p, H)
dimnames(FEVD)[[1]] <- toupper(colnames(Y))
dimnames(FEVD)[[2]] <- paste("S.", 1:m, sep = "")
dimnames(FEVD)[[3]] <- 0:H
FEVD
}
SVAR.hd <- function(SVAR) {
Y <- SVAR$var$datamat[, 1:m]
E <- wash(resid(SVAR$var))
m <- SVAR$var$K
p <- SVAR$var$p
B <- VAR.coefficients(SVAR$var)
P <- solve(SVAR$A, SVAR$B)
HD <- hd(B$Phi, P, Y, E, m, p, T)
dimnames(HD)[[1]] <- toupper(colnames(Y))
dimnames(HD)[[2]] <- c(paste("S.", 1:m, sep = ""), "NS")
dimnames(HD)[[3]] <- 1:T
HD
}
SVAR.erpt <- function(SVAR, H, vx, vy, cumulative = TRUE) {
m <- SVAR$var$K
p <- SVAR$var$p
B <- VAR.coefficients(SVAR$var)
P <- solve(SVAR$A, SVAR$B)
erpt(B$Phi, P, m, p, H, vx, vy, cumulative = cumulative)
}
# SVAR Tools (Bootstrap) ####
SVAR.sirf.boot <- function(SVAR, Amat, Bmat, H, gamma, Y.boot, cumulative = FALSE) {
m <- SVAR$var$K
p <- SVAR$var$p
I.boot <- array(NA, c(m, m, H + 1, R))
var.names <- colnames(SVAR$var$y)
for (r in 1:dim(Y.boot)[3]) {
RVAR.boot <- boot.estimate(var.names, Y.boot[, , r], m, p, lag.max, ic, resmat = SVAR$var$restrictions)
SVAR.boot <- SVAR(RVAR.boot, Amat = Amat, Bmat = Bmat, lrtest = FALSE, max.iter = 500)
I.boot[, , , r] <- SVAR.sirf(SVAR.boot, H, cumulative)
}
I.boot <- aperm(I.boot, c(4, 1, 2, 3))
Ic <- SVAR.sirf(SVAR, H, cumulative)
Il <- array(NA, dim(Ic))
Iu <- array(NA, dim(Ic))
for (h in 1:(H + 1)) {
for (j in 1:m) {
for (i in 1:m) {
ci <- boot.ci(I.boot[, i, j, h], gamma)
Il[i, j, h] <- ci[1]
Iu[i, j, h] <- ci[2]
}
}
}
dimnames(Il) <- dimnames(Ic)
dimnames(Iu) <- dimnames(Ic)
list(lb = Il, pe = Ic, ub = Iu)
}
SVAR.fevd.boot <- function(SVAR, Amat, Bmat, H, gamma, Y.boot) {
m <- SVAR$var$K
p <- SVAR$var$p
F.boot <- array(NA, c(m, m, H + 1, R))
var.names <- colnames(SVAR$var$y)
for (r in 1:dim(Y.boot)[3]) {
RVAR.boot <- boot.estimate(var.names, Y.boot[, , r], m, p, lag.max, ic, resmat = SVAR$var$restrictions)
SVAR.boot <- SVAR(RVAR.boot, Amat = Amat, Bmat = Bmat, lrtest = FALSE, max.iter = 500)
F.boot[, , , r] <- SVAR.fevd(SVAR.boot, H)
}
F.boot <- aperm(F.boot, c(4, 1, 2, 3))
Fc <- SVAR.fevd(SVAR, H)
Fl <- array(NA, dim(Fc))
Fu <- array(NA, dim(Fc))
for (h in 1:(H + 1)) {
for (j in 1:m) {
for (i in 1:m) {
ci <- boot.ci(F.boot[, i, j, h], gamma)
Fl[i, j, h] <- ci[1]
Fu[i, j, h] <- ci[2]
}
}
}
dimnames(Fl) <- dimnames(Fc)
dimnames(Fu) <- dimnames(Fc)
list(lb = Fl, pe = Fc, ub = Fu)
}
SVAR.erpt.boot <- function(SVAR, Amat, Bmat, H, vx, vy, gamma, Y.boot, cumulative = TRUE) {
m <- SVAR$var$K
p <- SVAR$var$p
E.boot <- matrix(NA, H + 1, R)
var.names <- colnames(SVAR$var$y)
for (r in 1:dim(Y.boot)[3]) {
RVAR.boot <- boot.estimate(var.names, Y.boot[, , r], m, p, lag.max, ic, resmat = SVAR$var$restrictions)
SVAR.boot <- SVAR(RVAR.boot, Amat = Amat, Bmat = Bmat, lrtest = FALSE, max.iter = 500)
E.boot[, r] <- SVAR.erpt(SVAR.boot, H, vx, vy, cumulative)
}
E.boot <- aperm(E.boot, c(2, 1))
Ec <- SVAR.erpt(SVAR, H, vx, vy, cumulative)
El <- rep(NA, H + 1)
Eu <- rep(NA, H + 1)
for (h in 1:(H + 1)) {
ci <- boot.ci(E.boot[, h], gamma)
El[h] <- ci[1]
Eu[h] <- ci[2]
}
list(lb = El, pe = Ec, ub = Eu)
}
SVAR2 <- SVAR(VAR2, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
Y.boot <- boot.replicate(VAR2, R, type)
ERPT <- SVAR.erpt.boot(SVAR2,Amat, Bmat, H.ERPT, 2, 1, gamma, Y.boot)
Y.boot <- boot.replicate(VAR2, R, type)
SVAR2 <- SVAR(VAR2, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
# A Matrix
Amat <- diag(m)
for (i in 2:m) {
for (j in 1:(i - 1)) {
Amat[i, j] <- NA
}
}
# B Matrix
Bmat <- matrix(0, m, m)
for (i in 1:m) {
Bmat[i, i] <- NA
}
R <- 500 # Number of bootstrap replications
type <- "nonparametric"
gamma <- 0.95 # Confidence level
SVAR2 <- SVAR(VAR2, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
SVAR2 <- SVAR(VAR2, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
SVAR2 <- SVAR(VAR2, Amat = Amat, Bmat = Bmat, lrtest= FALSE)
clear all
